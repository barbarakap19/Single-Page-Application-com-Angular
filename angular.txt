Curso DEvmedia

Minha primeira página Single Page Application com Angular

Um página que recarrega apenas um conteudo.

Ela carrega só uma parte do conteudo, no caso ela não precisa carregar a pagina inteira para mostrar as telas delas (conteudo dinamico)

Tecnologias

Typescript ( que ja vem no angular)
Angular 5
Node.Js
Angular CLI
HTML e CSS (para revisar nossas views)
Javascript

Angular Js diferente de angular

O PROJETO

Neste curso conheceremos aspectos fundamentais da programação com Angular, um dos frameworks JavaScript mais utilizados atualmente para a criação de aplicações cliente, que recebem/enviam dados para um servidor remoto, tendo seu próprio código completamente separado da implementação deste serviço.

Como cenário para a criação desta aplicação considere as necessidades do setor administrativo de uma clínica médica, que necessita visualizar rapidamente um resumo das consultas marcadas, assim como o seu faturamento em um determinado período.

Um Dashboard é o tipo de aplicação ideal neste caso, pois permite o agrupamento dos dados, permitindo serem facilmente visualizados e, portanto, será este o tipo de aplicação que criaremos.

Esta aplicação terá o comportamento de uma SPA que significa Single Page Application. Se você já utilizou o Facebook ou Gmail já sabe como funciona uma SPA, pois são aplicações cuja funcionalidade está concentrada em uma única página. Ao invés de carregar toda a página ou redirecionar o usuário para uma nova, apenas o conteúdo principal é atualizado dinamicamente, mantendo toda a estrutura ao seu redor estática.

Em nossa aplicação oferecemos um menu de navegação lateral, a partir do qual o usuário poderá escolher o conteúdo a ser apresentado na área principal da página.

Ao longo deste curso veremos que o Angular fornece toda a infraestrutura necessária para navegação através de rotas, manipulação do DOM, recebimento e processamento de documentos em formato JSON através da web, sendo uma opção perfeitamente adequada para este tipo de cenário.

Conforme mencionamos anteriormente, é comum que uma aplicação cliente necessite receber os dados a serem apresentados de um serviço remoto. Neste curso usaremos uma Web API que estará acessível a todos através da internet.
Por uma questão de praticidade esta Web API fornece apenas dados estáticos, ou seja, que não mudam entre as requisições e não requerem, portanto, que parâmetros sejam enviados. Ainda assim esta Web API é suficiente para entendermos como é criada uma aplicação cliente com o Angular.

CRIANDO O PROJETO

Um projeto Angular possui diversos arquivos, em grande parte destinados a criação da infraestrutura necessária para que a aplicação funcione. Para que não seja necessário criá-los manualmente utilizamos uma ferramenta chamada Angular CLI.

Angular CLI é uma ferramenta de linha de comando que procura automatizar diversas tarefas envolvidas na programação de uma aplicação Angular, dentre elas a criação do projeto.



Uma das formas de instalarmos esta ferramenta é através do gerenciador de pacotes do Node, o NPM. Para tal devemos ter o Node instalado em nosso ambiente de desenvolvimento. Além disso, uma vez que a Angular CLI é escrita em JavaScript será o Node o responsável por permitir que a utilizemos partir de um terminal, como um programa escrito em código nativo.

Para verificar se possuímos uma versão do Node em funcionamento podemos executar o comando node -v no terminal do sistema operacional, como mostra a Figura 1.

node -v

E agora, como instalar a Angular CLI?

Ainda no terminal, e com acesso à internet, execute o seguinte comando como administrador:

npm i @angular/cli -g

Criando o primeiro projeto

Para criar um novo projeto utilizamos o seguinte comando:

ng new treinamento-angular

Entendendo a estrutura do projeto

Conheceremos agora um pouco da estrutura de um projeto Angular e, em especial, o diretório src, onde será colocado o código principal da aplicação.

Diretório app: Aqui serão criados os componentes da aplicação. Um componente é a base para construirmos uma view, para isso utilizamos HTML, CSS e o TypeScript. Uma aplicação Angular é formada por vários componentes e cada um é responsável por exibir uma parte da aplicação.
Diretório assets: Neste diretório podemos colocar arquivos JavaScript, CSS e imagens ou qualquer outro arquivo que será acessado publicamente.
Diretório environments: Teremos uma aula específica para abordá-lo, mas aqui definimos variáveis e até mesmo funções a serem compartilhadas entre as classes da nossa aplicação.
Diretório node_modules: Aqui estão todas as dependências instaladas definidas no arquivo package.json. Este diretório também faz parte do Node.
Arquivo index.html: Este é o primeiro arquivo a ser carregado quando acessamos a aplicação através da URL http://localhost:4200. A partir dele será carregado todo o código JavaScript da aplicação e por meio dele iniciaremos o componente app.
Arquivo main.ts: Este arquivo contém a lógica que inicia uma aplicação Angular e a partir daí, marcações no HTML como <app-root></app-root> passam a ser reconhecidas como componentes.
Arquivo polyfills.ts: Neste arquivo são declaradas funções com o objetivo de executar o código JavaScript do projeto em diferentes navegadores, eliminando problemas de compatibilidade entre eles.
Arquivo Styles.css: Arquivo de CSS da aplicação.
Arquivo tsconfig.ts e tslint.ts: Estes arquivos contêm configurações básicas a compilação do código TypeScript. Para a maior parte dos projetos as configurações iniciais serão suficientes.
Arquivo package.json: Este arquivo é gerado pelo Node, contendo informações do nosso projeto como o nome, versão e licença. Aqui também são descritas as dependências do projeto.
Arquivos karma.conf.js e test.ts: Estes são arquivos para automatização de testes da aplicação.
Arquivo README.md: É um manual com um breve resumo do que podemos fazer com a nossa aplicação. Você pode editá-lo para informar como funciona a sua aplicação.
Arquivo .gitignore: Aqui informamos para o Git, ferramenta de versionamento de código, quais arquivos e diretórios não devem ser adicionados ao repositório de versionamento.

3. EXECUTANDO O PROJETO

Agora que criamos o projeto podemos executá-lo para vê-lo em funcionamento no navegador. Com isso seremos apresentados a um componente e ao seu papel dentro de uma aplicação Angular, bem como ao mecanismo que permite exibir conteúdo HTML.


Um projeto Angular recém criado contém uma página de apresentação, bem como o código necessário para executá-la. Podemos testá-lo utilizando o seguinte comando:

ng serve

O comando ng serve iniciará a aplicação deixando-a disponível a partir do endereço http://localhost:4200. Após executá-lo vá até o navegador e digite este endereço para ver a aplicação em execução.

Como foi carregada esta página?

Quando a aplicação é acessada, o arquivo index.html chama o componente <app-root></app-root>. No Angular, toda vez que precisarmos apresentar algo para o usuário, o HTML/CSS necessário para isso será escrito e adicionado a um componente. Veremos em detalhes como um componente é criado na próxima aula.

Abaixo temos o código necessário para a criação da classe AppComponent, em seguida, explicamos como a partir dessa classe o Angular consegue apresentar a página que vemos quando o endereço http://localhost:4200 é acessado:


1.import { Component } from '@angular/core';
2.
3.@Component({
4.    selector: 'app-root',
5.    templateUrl: './app.component.html',
6.    styleUrls: ['./app.component.css']
7.})
8.export class AppComponent {
10.    title = 'app';
11.}

Linha 8: export class AppComponent {

Iniciaremos a leitura deste código pela linha 8porque o mais importante deste arquivo é a declaração da classe “AppComponent”. Podemos ver que tornamos esta classe pública através da instrução export, que possibilita a sua importação em um outro arquivo. Este é um recurso da linguagem TypeScript e do JavaScript, não confunda com o Angular.

Linha 4: selector: 'app-root'

No atributo selector informamos o nome do componente, que corresponde a tag app-root utilizada para declará-lo no HTML da aplicação.

Linha 5: templateUrl: './app.component.html'

No atributo templateUrl informamos onde está o HTML do componente, neste caso no mesmo diretório que o arquivo no qual o componente foi declarado, por isso o caractere “./” antes do nome do arquivo app.component.html.

Linha 6: styleUrls: ['./app.component.css']

No atributo StyleUrls informamos onde está o arquivo de estilo do componente, que pode ser escrito em CSS ou SASS.

Linha 9: title = 'app';

Podemos perceber que esta classe contém o atributo title que possui o valor app, ou seja, um valor da minha classe para exibir no HTML.


Explorando o arquivo app.component.html

Abrindo o arquivo index.html temos o seguinte código:

1.<!--The content below is only a placeholder and can be replaced.-->
2.<div style="text-align:center">
3.    <h1>
4.        Welcome to {{ title }}!
5.    </h1>
6.</div>

Explicando o código

Linha 4 Welcome to {{ title }}!:

O Angular substituirá o valor {{title}} por app

No HTML conseguimos acessar os dados da classe, onde title é um atributo da classe AppComponent e o seu valor é appcomo vimos no código anterior. Assim, fica fácil manipular o HTML utilizando o Angular.

4. CRIANDO UM COMPONENTE OLÁ MUNDO

Antes de criarmos componentes mais complicados, iniciaremos com um que contém apenas um parágrafo com uma cor de texto personalizada, conhecendo assim a sua estrutura.

No Angular, um componente é responsável por exibir para o usuário uma interface. Portanto, toda vez que precisarmos apresentar algo para o usuário, o HTML/CSS necessário para isso será escrito e adicionado a um componente. Caso ele contenha funcionalidades, escreveremos nele o código TypeScript que as implementam.

O primeiro passo para criação de um componente é adicionar a interface Component ao projeto com a seguinte instrução:

1.import { Component } from '@angular/core';
2.
3.@Component({
4.    selector: 'ola-mundo', // seletor <ola-mundo></ola-mundo>
5.    templateUrl: './ola-mundo.component.html',
       // Caminho para o arquivo HTML
6.    styleUrls: ['./ola-mundo.component.css']
       // Caminho para os arquivos de Estilo
7.})
8.export class OlaMundoComponent {
9.
10.constructor() { }
11.}

Linha 1: import { Component } from ‘@angular/core’;

Note que precisamos importar Component do pacote @angular/core.

Linha 5: templateUrl: './ola-mundo.component.html', // Caminho para o arquivo HTML

O HTML será definido em um outro arquivo ola-mundo.component.html.

Linha 6: styleUrls: ['./ola-mundo.component.css'] // Caminho para os arquivos de Estilo

O CSS será definido no arquivo ola-mundo.component.css.

Nota: Podemos incluir mais que um arquivo de estilo, pois a propriedade styleUrls recebe um array [].

Linha 8: export class OlaMundoComponent {

Definimos a lógica dentro da classe OlaMundoComponent que está neste arquivo ola-mundo.component.ts.

Criando a estrutura de diretório do componente
Uma aplicação Angular pode ser composta de diversos componentes. A fim de seguirmos as orientações do framework com relação a organização, utilizamos o diretório app sempre que for preciso criar um novo componente. Por conversão, dentro deste diretório criamos uma nova pasta cujo nome será o nome do componente e nela adicionamos os arquivos necessários para criá-lo, como mostra a Figura 1.

Estrutura de diretório do ola-mundo.
Figura 1. Estrutura de diretório do ola-mundo.
Podemos agora iniciar a codificação do componente, escrevendo para isso código HTML, CSS e TypeScript.

HTML e CSS do componente
No arquivo ola-mundo.component.html incluiremos o seguinte conteúdo:

<p>Olá Mundo</p>
Com este HTML definimos a estrutura do componente e exibimos um parágrafo na página. Agora, com este CSS definimos a apresentação do componente e atribuímos uma cor ao parágrafo:

p { color: aqua; }
É importante citar que o CSS declarado para este parágrafo neste componente não afetará outros parágrafos declarados em outros componentes. Este recurso é chamado Shadow DOM e permite anexar ao componente uma parte do DOM completamente isolada do restante da página.

Criando a classe do componente
No arquivo ola-mundo.component.ts declaramos o código TypeScript para o componente. Ele será responsável, entre outras coisas, por unir a estrutura e apresentação do componente criadas anteriormente.

Para isso será necessário criar uma classe como visto no código abaixo:

1.import {Component} from ‘@angular/core’;
2.
3.@Component({
4.    selector: ‘ola-mundo’,
5.    templateUrl: ‘./ola-mundo.component.html’,
6.    styleUrls: [‘./ola-mundo.component.css’]
7.})
8.export class OlaMundoComponent {}
Parte deste código foi visto na aula anterior, incluindo a explicação sobre selector, templateUrl e styleUrls. Portanto, abaixo falaremos apenas da criação do componente.

Explicando o código
Linha 1: import {Component} from ‘@angular/core’;

Nesta linha importamos o decorator Component do pacote @angular/core. Nele incluímos metadados sobre a classe OlaMundoComponent, que incluem a localização dos arquivos utilizados na sua construção.

Linha 8: export class OlaMundoComponent

Nesta linha declaramos a classe OlaMundoComponent, que conterá as funcionalidades deste componente. Para torná-la acessível em outras partes da aplicação devemos preceder a palavra class por export.

Carregando o componente em um módulo
Por fim, precisamos carregar este componente em um módulo, adotado pelo Angular para descrevemos como as diferentes partes da aplicação funcionam em conjunto.

Abra o arquivo app.module.ts, localizado na pasta app

Nele é declarada a classe AppModule, que podemos ver abaixo:

1.import { AppComponent } from './app.component';
2.
3.import { OlaMundoComponent } from './ola-mundo/ola-mundo.component';
4.
5.@NgModule({
6. declarations: [
7.   AppComponent,
8.   OlaMundoComponent,
9. ],
10. imports: [
11.   BrowserModule
12. ],
13. providers: [],
14. bootstrap: [AppComponent]
15.})
16.export class AppModule { }

Explicando o código
Linha 3: import { OlaMundoComponent } from './ola-mundo/ola-mundo.component';

Precisamos importar o componente OlaMundoComponent para utilizar na linha 8.

Linha 8: OlaMundoComponent

Declaramos o componente em um módulo adicionando-o dentro do array declarations. Assim tornamos este componente disponível na aplicação.

Utilizando o componente
Agora podemos modificar o conteúdo do arquivo app.component.html, passando a apresentar o componente OlaMundoComponent em lugar da página padrão gerada pela Angular CLI. Para isso abra esse arquivo e insira a tag do componente, conforme demonstrado abaixo:

<ola-mundo></ola-mundo>
Note que utilizamos o seletor <ola-mundo></ola-mundo>, de acordo com o valor definido na propriedade selector no arquivo ola-mundo.component.ts. Escrevemos isso dentro de app.component.html, pois é ele que será carregado no index.html, como mostra o código abaixo:

1.<!doctype html>
2.<html lang="en">
3.    Restante do código...
4.
5.    <body>
6.       <app-root></app-root>
7.    </body>
8.
9.</html>
Explicando o código
Linha 6: <app-root></app-root>

O index.html carrega o componente app nesta linha.

Executando o código
Agora podemos acessar no browser e ver o componente funcionando

Na última aula vimos que a aplicação foi iniciada com o comando ng serve e, com isso, conseguimos visualizar o componente App no navegador. Agora entenderemos o que aconteceu durante este processo.

Agora que vimos como utilizar o comando ng serve para executar a aplicação, conheceremos melhor os detalhes por trás da execução deste comando.

Perceba que até o momento escrevemos componentes utilizando TypeScript, embora em nenhum momento nos preocupamos com a tradução deste código em código JavaScript para o navegador. Isso só foi possível porque esta é a primeira tarefa a ser executada pelo comando ng serve. Após isso, ele disponibiliza estes arquivos em um servidor web nativo, acessado a partir da porta 4200. E por isso, quando acessamos o endereço http://localhost:4200, vemos a aplicação em funcionamento.

Também faz parte desta infraestrutura um recurso chamado Live Reload, a partir do qual podemos editar um arquivo e vê-lo recarregado em sua última versão automaticamente no navegador, sem que para isso seja necessário recarregar a página.

Lembre-se que ng é o comando para chamarmos a Angular CLI, portanto é o parâmetro serve quem inicia, de fato, o modo de teste da aplicação.

Nota: Ao final do curso veremos que não utilizamos o ng serve para o ambiente de produção e sim o ng build, pois o ng serve consome muito recurso do servidor e devemos utilizá-lo apenas para testar a aplicação.

Criando um componente com a Angular CLI

Criar um componente manualmente é um processo repetitivo e que envolve cuidado com certos detalhes. Uma vez que uma aplicação pode conter inúmeros componentes podemos facilitar sua criação refazendo estes passos de forma automatizada com a Angular CLI.

O primeiro passo é remover tudo que fizemos na aula anterior, ou seja, excluir o diretório ola-mundo, remover a declaração dentro do arquivo app.module.ts, além de remover o import do OlaMundoComponent.


Criando um componente com a Angular CLI
Para criar um componente com a Angular CLI utilizamos o comando:

ng generate component nome-do-componente

Ou a sua forma abreviada:

ng g c nome-do-componente

Daremos ao componente o nome de painel-simples utilizando o comando de criação:

ng g c painel-simples

Além disso, quando utilizamos a Angular CLI não precisamos declarar o componente dentro de AppModule, pois isto é feito automaticamente pela ferramenta.

Note também que foi gerado um arquivo com o sufixo .spec.ts, que serve para escrevermos testes automatizados para o nosso componente.

Inspecionando o arquivo painel-simples.component.ts
Podemos observar que foi implementada uma interface em nosso componente, o OnInit. Veremos esta interface quando realizarmos uma requisição HTTP. O código gerado para o componente é apresentado abaixo:

1.import { Component , Input, OnInit } from '@angular/core';
2.
3.@Component({
4.selector: 'app-painel-simples',
5.templateUrl: './painel-simples.component.html',
6.styleUrls: ['./painel-simples.component.css']
7.})
8.export class PainelSimplesComponent implements OnInit {
E se observarmos bem, o seletor do componente tem um prefixo app. Criamos prefixos para indicar qual o domínio de um componente, uma vez que podemos ter dois componentes de mesmo nome sendo utilizados em contextos diferentes.

Nota: o prefixo app é padrão do Angular, mas podemos alterá-lo no arquivo .angular-cli.json, alterando a propriedade prefix.

Podemos ter conflitos entre nomes, por exemplo quando importamos um componente de outro projeto. Por isso costumamos usar o nome do projeto como prefixo para assim conseguirmos saber qual componente pertence a qual projeto. Embora esta nomenclatura seja opcional, é importante segui-la.

Iniciando o componente
Para iniciar o componente precisamos chamá-lo em app.component.html, pois já sabemos que é neste arquivo que declaramos o conteúdo a ser apresentado na página inicial:

<app-painel-simples></app-painel-simples>
Ao executar novamente a aplicação no navegador note que temos agora o texto padrão gerado pela Angular CLI painel-simples works!. Veremos como modificar este conteúdo ao longo do curso.

Adicionando o Bootstrap

Veremos nesta aula como instalar no projeto o Bootstrap para, a partir dele, determinarmos como será a apresentação do componente painel-simples.

Documentação
Há mais de uma forma de instalar o Bootstrap em um projeto Angular. Uma delas é baixando os arquivos do projeto e realizar a importação dos mesmos no index.html, como em qualquer site ou aplicação web. Entretanto, veremos como o Angular carrega arquivos de estilo.

Podemos instalar o Bootstrap através do comando:

npm i bootstrap

Após baixá-lo, o mesmo estará disponível no diretório node_modules do projeto.

Adicionando o Bootstrap ao projeto
No diretório raiz do projeto temos o arquivo .angular-cli.json, onde podemos definir configurações da Angular CLI. Para adicionar o Bootstrap colocamos o seu caminho dentro de styles, como mostra o código abaixo:

1."styles": [
2. "../node_modules/bootstrap/dist/css/bootstrap.min.css",
3. "styles.css"
4.],

Note que neste arquivo já é feita a importação do CSS padrão da aplicação, declarado em styles.css.

Explicando o código
Linha 2: "../node_modules/bootstrap/dist/css/bootstrap.min.css"

Adicionamos o arquivo de estilo no array styles.

Reiniciando o servidor
Precisamos reiniciar o servidor porque editamos as configurações da Angular CLI, então pare o ng serve e inicie novamente.

Para certificar que o Bootstrap foi carregado, podemos verificar o arquivo styles.bundle.js no console do navegador através da aba network

O Angular empacotou todos os arquivos de estilo em um único arquivo utilizando o Webpack. Você pode dar uma olhada no projeto do Webpack , mas não precisamos nos preocupar com isso, pois o Angular abstraiu toda esta complexidade.

Explorando um pouco mais o arquivo .angular-cli.json
Podemos carregar arquivos de JavaScript na propriedade scripts informando o caminho do arquivo JavaScript, ou seja, da mesma forma como carregamos arquivos de estilo:

1."styles": [
2. "../node_modules/bootstrap/dist/css/bootstrap.min.css",
3. "styles.css"
4.],
5."scripts": [],
Esta função não será utilizada no curso, mas o Angular está pronto para receber código JavaScript de terceiros

8. Conhecendo o Input e o ng-content

Precisamos finalizar a criação do painel-simples, adicionando as classes do Bootstrap. Veremos como manipular o HTML com a sintaxe do Angular.

Documentação
Adicionaremos o código que representa um painel do Bootstrap:

1. <div class="col-sm-6">
2.   <div class="panel panel-info">
3.       <div class="panel-heading">
4.           <h3 class="panel-title">Painel Simples</h3>
5.       </div>
6.       <div class="panel-body">
7.           <h3>Conteúdo do painel</h3>
8.       </div>
9.   </div>
10.</div>
Não detalharemos o código, mas caso tenha dificuldades aqui no portal DevMedia temos um curso específico para Bootstrap.

Podemos atribuir valores ao componente configurando a sua classe, como mostra o código abaixo:

1. export class PainelSimplesComponent implements OnInit {
2. titulo = "Painel simples";
3. col = 6;
4. tipo = "info";
5.
6. constructor() { }
7. ngOnInit() {}
8. }
Explicando o código
Linha 2: titulo = "Painel simples";

Adicionando o valor Painel simples no atributo titulo.

Linha 3: col = 6;

Adicionando o valor 6 no atributo col.

Linha 4: tipo = "info";

Adicionando o valor info no atributo tipo.

Definimos atributos na classe PainelSimplesComponent e ao definir estes valores conseguimos acessá-los no HTML. Veremos isto a seguir.

Utilizando os atributos de um componente no HTML
E para exibir estes dados utilizamos a sintaxe do Angular, como mostra o código abaixo:

1. <div class="col-sm-{{col}}">
2.   <div class="panel panel-{{tipo}}">
3.       <div class="panel-heading">
4.           <h3 class="panel-title">{{titulo}}</h3>
5.       </div>
6.       <div class="panel-body">
7.           <h3>Conteúdo do painel</h3>
8.       </div>
9.   </div>
10. </div>
Explicando o código
Linha 1: <div class="col-sm-{{col}}">

Linha 2: <div class="panel panel-{{tipo}}"> >

Linha 4: <h3 class="panel-title">{{titulo}}</h3>

Envolvendo o nome do atributo da classe com chaves duplas {{}} conseguimos acessá-lo no HTML.

Adicionando Input ao componente
Podemos tornar este componente configurável, pois não queremos exibir o mesmo título sempre. Para isso podemos anotar os atributos da classe com @Input, como mostra o código abaixo:

1.import { Component, OnInit, Input } from '@angular/core';
2.
3.export class PainelSimplesComponent implements OnInit {
4.    @Input() titulo;
5.    @Input() col;
6.    @Input() tipo = "info";
7.
8.    constructor() { }
9.    ngOnInit() {}
10.}
Explicando o código
Linha 1: import { Component, OnInit, Input } from '@angular/core';

Importando Inputdo pacote @angular/core. Iremos utilizá-lo nas linhas 4, 5 e 6.

Linha 4: @Input() titulo;

Linha 5: @Input() col;

Linha 6: @Input() tipo = "info";

Recebemos dados através do decorator @Input(). Note que no tipo do painel foi atribuído o valor info, que é padrão, caso nenhum valor seja passado.

Configurando o AppComponent
E quem passará estas configurações vistas anteriormente? Será o componente AppComponent no arquivo app.component.html:

1. <app-painel-simples titulo="Painel Simples" col="6"
tipo="info"></app-painel-simples>
Explicando o código
Linha 1: <app-painel-simples titulo="Painel Simples" col="6" tipo="info"></app-painel-simples>

Passamos a configuração para o componente através de atributos, informando qual o valor que cada um deve possuir. É bem similar ao uso de atributos nos elementos nativos do HTML.

Definimos o valor inicial info para o atributo tipo na classe PainelSimplesComponent, então podemos omitir este parâmetro, como mostra o código abaixo:

<app-painel-simples titulo="Painel Simples" col="6"></app-painel-simples>
Adicionando o ng-content
Queremos alterar o conteúdo do body deste painel, sem passar apenas uma string ou valores numéricos, mas sim passar tags do HTML, parecido com o código abaixo:

1.<app-painel-simples titulo="Painel Simples" col="6">
2.    <h3>Tag do HTML h3</h3>
3.    <p>Tag do HTML p </p>
4.</app-painel-simples>
Contudo, apenas com o Input não é possível e, para isto, devemos utilizar o ng-content. Portanto, no HTML do painel simples devemos escrever o código abaixo:

1. <div class="col-sm-{{col}}">
2.    <div class="panel panel-{{tipo}}">
3.       <div class="panel-heading">
4.           <h3 class="panel-title">{{titulo}}</h3>
5.       </div>
6.       <div class="panel-body">
7.           <ng-content></ng-content>
8.       </div>
9.   </div>
10.</div>

OBS.: erro de versoes do bootstrap

soluções apresentadas

1 - conversor online de Bootstrap 3 para Bootstrap 4: 
http://upgrade-bootstrap.bootply.com/ 

2 - Trocar o panel por card

<div class="col-sm-6"> 
<div class="card"> 
<div class="card-header"> 
<h3 class="card-title">Painel Simples</h3> 
</div> 
<div class="card-body"> 
<h3>Conteúdo do painel</h3> 
</div> 
</div> 
</div> 

3 - Caso opti pela versão 4 instalar mais duas bibliotecas, a popper.js@^1.12.9 e a jquery@1.9.1 
Para adicionar outras libs de terceiros, utilize o arquivo angular-cli.json que encontra-se na raiz do projeto. 

linha 25: "scripts": [], 
Nesta linha é possível informar quais arquivos de JavaScript devem ser iniciados com o Angular, então adicione aqui o caminho para o arquivo do JQuery, propper.js e bootstrap.min.js exatamente nesta ordem. 

Obs: O bootstrap.min.js é baixado automaticamente com o bootstrap, os demais scripts, podem ser instalados com o npm.

4 -  Desinstalar o bootstrap 4 "npm uninstall bootstrap" e instalar o 3 com "npm install bootstrap@3"

9. Módulos

Veremos aqui um conceito fundamental na criação de componentes: por que declará-los em módulos? Com isso falaremos também sobre as motivações do Angular em adotar este mecanismo.

Documentação
Organizamos uma aplicação Angular separando os componentes em módulos. Isto nos permite utilizá-los apenas quando necessário, trazendo maior desempenho para aplicação, ou seja, o Angular só carrega o componente se o seu módulo for carregado.

Observando de outro ponto de vista, os módulos são necessários para carregar um componente, ou seja, precisamos declarar um componente dentro de um módulo para torná-lo acessível no HTML.

Nota: O próprio Angular se divide em módulos para também se organizar melhor. Por exemplo, no módulo de formulários encontramos classes que estão relacionadas à construção de um formulário, enquanto no módulo HTTP encontramos classes que nos ajudam a fazer uma requisição para um servidor que está no back-end.

O AppModule só terá acesso ao componente B porque somente ele é exportado. Entretanto, o Componente B consegue utilizar o Provider B e o Componente C porque os três estão no mesmo módulo. É como se o módulo B fosse uma classee o Componente B um método público, mas o Componente Ce o Provider B são métodos privados.

Explorando a estrutura de um módulo
Podemos observar que o módulo é uma classe anotada com @NgModule e utilizamos este decorator para configurar a classe:

@NgModule
export class AppModule { }
Note que para utilizar @NgModule precisamos importar NgModule do pacote @angular/core. Na importação não utilizamos o caractere “@” antes do nome:

import { NgModule } from '@angular/core';
Note que uma classe só se torna um módulo do Angular quando anotamos com o @NgModule.

Entendendo a estrutura de um módulo
Observe agora as propriedades definidas pelo decorator @NgModule:

01.@NgModule({
02.    declarations: [
03.        AppComponent,
04.        PainelSimplesComponent,
05.    ],
06.    imports: [
07.        BrowserModule
08.    ],
09.    providers: [],
10.    bootstrap: [AppComponent],
11.    exports:[]
12.})
13.export class AppModule { }
Explicando o código
Linha 2: declarations: [

Sabemos que precisamos declarar um componente dentro do array declarations. Isso porque um componente precisa ser inicializado, pois só conseguimos acessá-lo no HTML se declararmos em um módulo. Este, por sua vez, precisa ser inicializado, mas no nosso caso, uma vez que AppModule é o módulo principal da aplicação, não precisamos carregá-lo, já que isso é feito automaticamente.

Linha 6: imports: [

Lembra que mencionamos que um módulo pode ser utilizado em outros projetos? É através do imports que utilizamos módulos de outros projetos. Quando isso ocorre, herdamos todos os componentes exportados para o mesmo. Quando importamos um módulo em AppModule estamos inicializando-o e, com isso, todos os componentes exportados ficam acessíveis na aplicação.

Linha 11: exports:[]

Esta propriedade exports serve para exportar os componentes definidos no array declarations, ou seja, não conseguimos importar um módulo e acessar os seus componentes se eles não forem exportados. Precisamos exportá-los para torná-los públicos.

Uma vez que AppModule é um módulo com características especiais, nele não é necessário utilizar exports, pois será carregado automaticamente e seus componentes já estarão acessíveis.

Benefício de utilizar módulos
O maior benefício de se utilizar módulos é que podemos carregar apenas o módulo necessário para uma certa ação a ser realizada pelo programa. Por exemplo, até agora não importamos o módulo HTTP, pois ele não foi necessário e isto tornará a nossa aplicação menor e mais ágil, já que nenhum código está sendo adicionado além daquele que é realmente necessário.

10. Adicionando a Barra de Navegação

Em muitos casos precisamos construir a aplicação sobre um template pronto, que já contém algum HTML/CSS, porém ainda sem funcionalidade. Vamos iniciar a criação da interface do Dashboard, partindo da sua barra de navegação. Com isso veremos como programar a partir de um template pronto.

Documentação
Assim como vimos na criação do “Olá Mundo”, criamos funcionalidade a partir de componentes. Sendo assim, o primeiro passo para criar a barra de navegação é criar um componente que a representa e fazemos isto com a Angular CLI:

ng g c barra-navegacao --spec false

O parâmetro --spec false foi adicionado para não gerar o arquivo de teste, como vimos na aula 4. Não precisamos deste arquivo neste curso, pois testes estão fora deste escopo inicial.

Agora copiaremos o HTML responsável por exibir esta barra de navegação para o arquivo barra-navegacao.component.html:

1.<nav class="navbar navbar-inverse">
2.    <div class="container-fluid">
3.        <div class="navbar-header">
4.            <button type="button" class="navbar-toggle pull-left">
5.                <span class="icon-bar"></span>
6.                <span class="icon-bar"></span>
7.                <span class="icon-bar"></span>
8.            </button>
9.            <a class="navbar-brand" href="#">Administrador</a>
10.        </div>
11.        <div class="collapse navbar-collapse">
12.            <ul class="nav navbar-nav navbar-right">
13.                <li><a href="#">Sair</a></li>
14.            </ul>
15.        </div>
16.    </div>
17.</nav>
Adicionaremos agora o CSS deste componente, que fica no arquivo barra-navegacao.component.css:

1. .navbar{
2.   margin: 0;
3.   border-radius: 0;
4. }
5. .navbar-toggle{
6.   display: inline-block;
7.   margin-left: 10px;
8. }
Entretanto, não basta criar o componente, pois precisamos chamá-lo no HTML. Sendo assim, no app.component.html escrevemos o seguinte código:

1.<app-barra-navegacao></app-barra-navegacao>
2.  <div class="main">
3.      <div class="content">
4.          <app-painel-simples
5.          titulo="Consultas Marcadas Últimos 30 dias"
6.          col="6">
7.              <h3 class="text-center">120</h3>
8.           </app-painel-simples>
9.          </div>
10.   </div>

Explicando código

Na linha 1 estamos utilizando o componente barra-navegacao. Note que as div’s main e content estão relacionadas à estrutura exigida pelo Bootstrap para que seu CSS funcione como o esperado. Entretanto, o Bootstrap é apenas um elemento de apoio nesta construção. O ponto mais importante que desejamos demonstrar aqui é como podemos construir um componente do Angular a partir de um template existente.

11. Adicionando o Menu Lateral

Para finalizar a estrutura HTML básica da aplicação, adicionaremos nela o menu lateral

Neste ponto já podemos perceber que cada trecho de HTML em uma aplicação, ao qual atribuímos certo comportamento, deve estar contido em um componente. Sendo assim, o primeiro passo na construção do menu lateral é criar um componente. Faremos isso com o seguinte comando:

ng g c menu-lateral --spec false
Adicionaremos o HTML no arquivo menu-lateral.component.html para representar o template do componente:

1.<div class="menu menu-open">
2. <ul>
3.   <li class="visible-xs"><a href="#">Sair</a></li>
4. </ul>
5.</div>
Adicionaremos o CSS no arquivo menu-lateral.component.css para dar o estilo ao componente:

1. .menu {
2.   width: 0px;
3.   height: 100%;
4.   border-top: 1px solid #333;
5.   background-color: #222;
6.   flex-shrink: 0;
7.   overflow: hidden;
8.   transition: width .5s;
9.}
10.
11. .menu.menu-open {
12.    width: 300px;
13.}
14.
15. .menu ul {
16.   list-style: none;
17.   padding: 10px 0px;
18.}
19.
20. .menu ul li.active {
21.   background-color: #080808;
22.}
23.
24. .menu ul li a {
25.   display: block;
26.   color: #9d9d9d;
27.   padding: 10px 15px;
28.   white-space: nowrap;
29.}
30.
31. .menu ul li:hover a,
32. .menu ul li.active a {
33.   color: white
34.}

Adicionando no arquivo app.component.html
Lembrando que precisamos iniciar o componente menu-lateral em app.component.html, como mostra o código abaixo:

1. <app-barra-navegacao></app-barra-navegacao>
2. <div class="main">
3.   <app-menu-lateral></app-menu-lateral>
4.   <div class="content">
5.       <app-painel-simples titulo="Consultas Marcadas 
Últimos 30 dias" col="6">
6.           <h3 class="text-center">120</h3>
7.       </app-painel-simples>
8.   </div>
9.</div>
Explicando código
Linha 4 <app-menu-lateral></app-menu-lateral>. Chamando o componente menu-lateral


12. Criando a view Resumo

Adicionaremos a primeira página da aplicação, que apresentará um resumo do faturamento e das consultas para o usuário. Com isso veremos como o Angular cria uma view e agrupa nela diversos componentes.


Documentação
Uma boa prática é tratar uma view como um componente, assim teremos um componente chamado Resumo, que será responsável por carregar todos os componentes contidosnesta view. Utilizaremos a Angular CLI para gerar este componente:

ng g c resumo --spec false

Agora, tudo que representa o resumo será declarado dentro deste componente, ou seja, o app.component.html não terá mais o painel, pois isto é responsabilidade da view resumo. A view, por sua vez, será carregada pelo AppComponent, um procedimento que já vimos ser feito com outros componentes anteriormente. Editamos o arquivo app.component.html para aplicar esta prática:

1. <app-barra-navegacao></app-barra-navegacao>
2. <div class="main">
3.  
4.   <app-menu-lateral></app-menu-lateral>
5.   <div class="content">
6.       <app-resumo></app-resumo>
7.   </div>
8.</div>
Explicando código
Linha 6: <app-resumo></app-resumo>. Chamando o componente resumo, que representará a view de resumo, no AppComponent.

Codificando o componente resumo
E agora, o trecho de código que estava dentro de app, mas que representava o conteúdo da view resumo, colocamos no arquivo resumo.component.html:

1.<app-painel-simples titulo="Consultas Marcadas Últimos 30 dias" col="6">
2.   <h3 class="text-center">120</h3>
3.</app-painel-simples>
Adicionando o código que estava em AppComponente para dentro do componente Resumo

Nota: Perceba que só removemos o painel que representava o resumo da aplicação, a barra de navegação e outros componentes ficaram em AppComponent.

Terminando de codificar o componente resumo
Com isso temos a mesma apresentação de antes, porém agora o nosso código está mais organizado, pois temos uma view trazendo o resumo da aplicação.

Precisamos adicionar mais código HTML para preencher o restante da view, pois o Resumo conterá diversos painéis, assim como vimos na aula de apresentação do projeto. Adicionaremos estes painéis com o código abaixo.

1.<app-painel-simples titulo="Consultas Marcadas
 Últimos 30 dias" col="6">
2.   <h3 class="text-center">87</h3>
3.</app-painel-simples>
4.
5.<app-painel-simples titulo="Consultas Marcadas 
Próximos 30 dias" col="6">
6.   <h3 class="text-center">79</h3>
7.</app-painel-simples>
8.
9.<app-painel-simples col="6" titulo="Faturamento Anterior">
10.   <div class="box-faturamento">
11.       <div class="col-md-10">
12.           <h1 class="text-left">R$100.000</h1>
13.       </div>
14.       <div class="alert col-md-2 sm alert-success">
15.           <b>10%</b>
16.       </div>
17.   </div>
18.</app-painel-simples>
19.
20.<app-painel-simples col="6" titulo="Faturamento Provisão">
21.   <div class="box-faturamento">
22.       <div class="col-md-10">
23.           <h1 class="text-left">R$100.000</h1>
24.       </div>
25.       <div class="alert col-md-2 sm alert-danger">
26.           <b>10%</b>
27.       </div>
28.   </div>
29.</app-painel-simples>
Precisamos também dar um estilo um pouco melhor para o componente Resumo. Para isso criamos o CSS abaixo. Ele será responsável por alinhar o conteúdo interno do painel.

1. .box-faturamento {
2.   padding: 30px;
3. }
4.
5. .box-faturamento h1 {
6.   margin: 0;
7.}
Copiando os dados da API
Podemos ver que este componente não está preparado para receber os dados do servidor, pois os dados estão fixos no HTML. Neste momento precisamos nos conectar a API e processar os dados recebidos por ela, apresentando-os nos painéis.

Antes disso, veremos como processar o json de resposta dessa API. Para isso copiamos os dados da API que representam a view de resumo, acessando a url:

http://projeto.devmedia.com.br/php/api-dashboard/api/resumo

E, então, adicionamos este json na classe:

1. export class ResumoComponent implements OnInit {
2.
3. resumo = {
4.   consultas : {
5.     anteriores : {
6.       total : 87,
7.       detalhes : [
8.           { especialidade : "Cardiologia", quantidade : 20 },
9.           { especialidade : "Clínica Geral", quantidade : 30 },
10.       ]
11.     },
12.     marcadas : {
13.       total : 79,
14.       detalhes : [
15.           { especialidade : "Cardiologia", quantidade : 19 },
16.           { especialidade : "Clínica Geral", quantidade : 28 },
17.       ]
18.     }
19.   },
20.   faturamento : {
21.     anterior : {
22.       valor : 100000,
23.       comparativo : 19
24.     },
25.     previsao : {
26.       valor : 90000,
27.       comparativo : -10 
28.     }
29.   }
30. };
31.
32. ...Restante do código
33.}
Explicando código
Linha3 resumo = {. Criando o atributo resumo e atribuindo os dados que recebemos da API, logo abaixo, exibiremos estes dados no HTML

Codificando o HTML do componente resumo
Queremos exibir os dados da classe no HTML, fazemos isto utilizando a sintaxe do Angular:

1. <app-painel-simples titulo="Consultas Marcadas Últimos 30 dias"
 col="6">
2.       <h3 class="text-center">
{{resumo.consultas.consultas_30dias_anteiores}}</h3>
3.   </app-painel-simples>
4.  
5.   <app-painel-simples titulo="Consultas Marcadas Próximos 30 dias"
 col="6">
6.       <h3 class="text-center">
{{resumo.consultas.consultas_30dias_posteriores}}</h3>
7.   </app-painel-simples>
8.  
9.   <app-painel-simples col="6" titulo="Faturamento Anterior">
10.       <div class="box-faturamento">
11.           <div class="col-md-10">
12.               <h1 class="text-left">
{{resumo.faturamento.anterior.valor}}</h1>
13.           </div>
14.           <div class="alert col-md-2 sm">
15.               <b>{{resumo.faturamento.anterior.comparativo}}%</b>
16.           </div>
17.   </div>
18.   </app-painel-simples>
19.
20.   <app-painel-simples col="6" titulo="Faturamento Previsão">
21.       <div class="box-faturamento">
22.           <div class="col-md-10">
23.               <h1 class="text-left">
{{resumo.faturamento.previsao.valor}}</h1>
24.           </div>
25.           <div class="alert col-md-2 sm">
26.               <b>{{resumo.faturamento.previsao.comparativo}}%</b>
27.           </div>
28.       </div>
29.   </app-painel-simples>

Explicando código

Linha 2 <h3 class="text-center">{{resumo.consultas.consultas_30dias_anteiores}}</h3>. 

Nesta linha acessamos o objeto resumo e, partir dele, a propriedade consultas_30dias_anteiores do objeto consultas. Faremo este mesmo procedimento para exibir os demais dados contidos neste json.

13. Manipulando classes do HTML

É bem comum precisarmos manipular o atributo class do elemento HTML quando desenvolvemos web sites. No Angular, contamos com uma sintaxe especial para isso que, aplicada ao HTML, nos permite resolver este problema.

Documentação
Uma das formas de manipular uma classe CSS é através atributo class de cada elemento do HTML. Considere, por exemplo, o seguinte trecho de código:

<h3 [class.text-center]=”true”>Um texto qualquer</h3>
Com ele, conseguimos habilitar ou desabilitar a classe text-center, utilizando o valor trueou false. Com este código conseguimos gerar o seguinte HTML:

<h3 class=”text-center”>Um texto qualquer</h3>
Neste caso, o atributo class só está presente porque a expressão [class.text-center] recebeu o valor true.

Podemosainda passar o valor de um atributo para esta expressão:

<h3 [class.text-center]=”centraliza”></h3>
Sendo centraliza um atributo definido na classe do componente que contém o valor true ou false, como mostra o código abaixo:

@Component
class MeuComponente {
    centraliza = true;
}
NgClasse
Há ainda uma outra forma de obtermos o mesmo resultado, utilizando a diretiva NgClass>. O código abaixo demonstra alguns casos de uso dessa diretiva:

1. <p [ngClass]="'classe1 classe2'">...</p>
2.
3. <p [ngClass]="['classe1', 'classe2']">...</p>
4.
5.<p [ngClass]="{'classe1': true, 'classe2': false, 'classe3': true}"
>...</p>
6.
7.<p [ngClass]="{'classe1 classe2 classe3' : true}">...</p>
Explicando código
Linha 1 <p [ngClass]="'classe1 classe2'">...</p>. Podemos passar as classes que queremos adicionar através de uma string e o resultado será: <p class=”classe1 classe2”>...</p>

Linha 3 <p [ngClass]="['classe1', 'classe2']">...</p>. A diretiva ngClass também aceita um array de Strings, neste caso o resultado será: O resultado será: <p class=”classe1 classe2”>...</p>

Linha 5 <p [ngClass]="{'classe1': true, 'classe2': false, 'classe3': true}">...</p>. Configuramos também através de um objeto e a propriedade que possuir o valor true será incluída como uma classe do elemento. O resultado será: <p class=”classe1 classe3”>...</p>

Linha 7 <p [ngClass]="{'classe1 classe2 classe3' : true}">...</p>.Outra forma de configurar o ngClass através de um objeto, desta forma passamos a propriedade com todas as classes que queremos adicionar, O resultado será: <p class=”classe1 classe2 classe3”>...</p>

Utilizando o NgClass com if ternário
A melhor sintaxe para o nosso caso é o seguinte código:

1. <div class="alert col-md-2 sm"
2. [ngClass]="resumo.faturamento.anterior.comparativo
 >= 0 ? 'alert-success' : 'alert-danger'">
No código acima, utilizamos um if ternário para atribuir as classes alert-success ou alert-danger no elemento.

Explicando código
Linha2 [ngClass]="resumo.faturamento.anterior.comparativo >= 0 ? 'alert-success' : 'alert-danger' ">: Se o comparativo for maior ou igual a 0 queremos apresentar alert-success caso contrário alert-danger.Foi utilizado um if ternário tornando a escrita do código menor, é muito comum o uso de if ternário em diversas linguagens, não só no JavaScript.

Finalizando o código
Para finalizar, adicionamos as mesmas classes ao painél de previsão, como visto no código a seguir.

<div class="alert col-md-2 sm" [ngClass]="resumo.faturamento.previsao
    .comparativo >= 0 ? 'alert-success' : 'alert-danger' ">

14. Pipes

Constantemente estamos manipulando o DOM em aplicações web e é bem comum querer tratar um dado vindo do servidor, seja filtrando elementos de um array ou formatando para valores monetários. Veremos como fazer isto com pipes.

Documentação
É bem comum precisarmos formatar um valor monetário e este trabalho é bem simples quando utilizamos pipes. Fazemos isto como mostra o código abaixo:

1. <h1 class="text-left">
2. {{resumo.faturamento.previsao.valor | currency}}
3. </h1>
4.
5. <h1 class="text-left">
6. {{resumo.faturamento.previsao.valor | currency:'BRL'}}
7. </h1>
Explicando código
Linha 2 {{resumo.faturamento.previsao.valor | currency}}:Observe que apenas utilizamos o caractere “|” que também é chamado de pipe e logo após chamamos o pipe do Angular currency, e automaticamente o valor será exibido como monetário.

Linha 6 {{resumo.faturamento.previsao.valor | currency:'BRL'}}: Podemos ainda especificar qual moeda estamos trabalhando, em nosso caso real.

Nota: Temos diversas siglas que podemos utilizar com os pipe currency, confira a lista das siglas abaixo na seção Links úteis, o mesmo também é sugerido pela documentação oficial do Angular.
Pipe lowercase e uppercase
Para visualizar um outro exemplo, utilizaremos uma tag do HTML chamada pre, então adicione o seguinte código ao final do arquivo app.component.html:

1. <pre>
2.   {{'UM TEXTO QUALQUER' | lowercase}}
3.   {{'um texto qualquer' | uppercase}}
4. </pre>
Explicando código
Linha 1 <pre>: Utilizando a tag pre do HTML para dar uma visualização melhor, isto não faz parte do Angular.

Linha 2 {{'UM TEXTO QUALQUER' | lowercase}}: Converte o texto maiúsculo para minúsculo.

Linha 3 {{'um texto qualquer' | uppercase}} Converte o texto minúsculo para maiúsculo.

JSON
Um problema recorrente é formatar um dado JSON na view, para que possamos observar como é montado a sua estrutura, para isto utilizamos o pipe json:

<pre>{{ resumo | json }}</pre>

Nota: Importante observar que o Bootstrap adicionou um estilo para a tag pre, por isso temos bordas e este fundo cinza.

Links úteis
Confira as possíveis siglas do pipe currency na ISO 4217


15. Criando a view consulta e o NgFor

Criaremos a view de consultas assim como vimos na apresentação do projeto. Posteriormente será necessário iterar numa lista e exibir cada item, para isto utilizaremos o NgFor.

Documentação
Criaremos o componente que será responsável pela view consulta com o comando abaixo:

ng g c consulta --spec false

Note que, neste momento, não é possível navegar entre o ResumoComponent e ConsultaComponent, então é preciso remover o resumo de app.component.html e adicionar componente consulta em seu lugar, até entender como navegar entre componentes.

1. <app-barra-navegacao></app-barra-navegacao>
2.<div class="main">
3.   <app-menu-lateral></app-menu-lateral>
4.   <div class="content">
5.       <app-consulta></app-consulta>>
6.   </div>
7.</div>
Agora copiamos os dados a view de consultas, acessando a URL:

http://projeto.devmedia.com.br/php/api-dashboard/api/consulta.

Adicionamos este JSON na classe consulta com o seguinte código:

1.import { Component, OnInit } from '@angular/core';
2.
3.@Component({
4. selector: 'app-consulta',
5. templateUrl: './consulta.component.html',
6. styleUrls: ['./consulta.component.css']
7.})
8.export class ConsultaComponent implements OnInit {
9.
10. consultas = {
11.   "realizadas" : [
12.       { "especialidade" : "Cardiologia", "quantidade" : 20 },
13.       { "especialidade" : "Clínica Geral", "quantidade" : 30 },
14.       { "especialidade" : "Dermatologia", "quantidade" : 14 }, 
15.       { "especialidade" : "Gastroenterologia", "quantidade" : 10 },
16.       { "especialidade" : "Pediatria", "quantidade" : 13 }
17.   ],
18.   "marcadas" : [
19.       { "especialidade" : "Cardiologia", "quantidade" : 19 },
20.       { "especialidade" : "Clínica Geral", "quantidade" : 28 },
21.       { "especialidade" : "Dermatologia", "quantidade" : 13 },
22.       { "especialidade" : "Gastroenterologia", "quantidade" : 8 },
23.       { "especialidade" : "Pediatria", "quantidade" : 11 }
24.   ]
25. }
26.
27. constructor() { }
28. ngOnInit() {}
29.
30.}
Explicando o código
Linha 10 consultas = {...: Criando o atributo consultas na classe ConsultaComponent e atribuindo o valor extraído da API.

Linha 11:"realizadas" : [ Array que conterá todas as consultas realizadas da aplicação.

Linha 18: "marcadas" : [ Array que conterá todas as consultas marcadas da aplicação.

Adicionando o HTML
Agora editamos o consulta.component.html, pois lá que adicionamos o HTML do componente.

1.<app-painel-simples tipo="primary" titulo="Consultas Realizadas
 - Últimos 30 dias" col="6">
2. <table class="table table-hover">
3.   <thead>
4.       <tr>
5.           <th>Especialidade</th>
6.           <th>Quantidade</th>
7.       </tr>
8.   </thead>
9.   <tbody>
10.     <tr *ngFor="let consulta of consultas.realizadas">
11.       <td>{{consulta.especialidade}}</td>
12.       <td>{{consulta.quantidade}}</td>
13.     </tr>
14.   </tbody>
15. </table>
16.</app-painel-simples>
Explicando o código
Linha 10 <tr *ngFor="let consulta of consultas.realizadas">: Navegando no array com a diretiva NgFor. Para iterar nesta lista é necessário definir qual o array e neste caso é consultas.realizadas array que está na nossa classe ConsultaComponent. let consulta/b> estamos criando uma variável chamada “consulta” para cada índice do array. A palavra for faz parte da sintaxe, então precisamos seguir exatamente como foi escrito.

Linha 11 e 12 <td>{{consulta.especialidade}}</td> e <td>{{consulta.quantidade}}</td>: Em cada iteração queremos acessar o atributo especialidade e quantidade, acessamos através da variável consulta que declaramos com let consulta na linha 10. Para cada iteração será criado um <tr> com seus respectivos <td>.

Adicionando a tabela marcadas
Adicionamos as consultas realizadas, precisamos adicionar as consultas marcadas, fazemos isto com o código abaixo:

1.<app-painel-simples tipo="primary" titulo="Consultas Marcadas
 - Próximos 30 dias" col="6">
2. <table class="table table-hover">
3.   <thead>
4.       <tr>
5.           <th>Especialidade</th>
6.           <th>Quantidade</th>
7.       </tr>
8.   </thead>
9.   <tbody>
10.     <tr *ngFor="let consulta of consultas.marcadas">
11.       <td>{{consulta.especialidade}}</td>
12.       <td>{{consulta.quantidade}}</td>
13.     </tr>
14.   </tbody>
15. </table>
16.</app-painel-simples>
É basicamente o mesmo código escrito anteriormente, só mudamos o título e o array.

Links úteis
Acesse a API Dashboard.

16. Melhorando a view consulta

Repetição de código não é bom. Identificando que temos o mesmo comportamento em mais de uma parte da aplicação, devemos abstrair essa funcionalidade em um componente e, então, utilizá-lo.

Documentação
O Componente consulta exibe duas tabelas contendo as consultas marcadas e as realizadas. Podemos notar que o HTML destas suas áreas é bem similar. Para evitar a repetição de código, precisamos criar um componente que encapsula esse código repetido.

Daremos a esse componente o nome de consulta-por-especialidade, como visto abaixo no comando de criação de componentes.

ng g c consulta/consulta-por-especialidade --spec false
Nota: Por questão de organização criamos o componente dentro do diretório consulta, pois este componente possui a finalidade de trazer uma tabela de consultas, então nada melhor do que estar dentro do diretório consulta.

Este componente terá os seguintes atributos consultas e titulo:
1. export class ConsultaPorEspecialidadeComponent implements OnInit {
2.
3. @Input() consultas;
4. @Input() titulo;
5. 
6. constructor() {}
7. ngOnInit() {}
8.
9.}
Veja que queremos construir um componente que contém a nossa tabela. Vimos que as únicas coisas que mudam entre uma tabela e outra é o título e o array de consultas. Vamos receber estes dados de fora, por isso adicionamos @Input().

Agora colocaremos o seguinte código dentro de consulta-por-especialidade.component.html:

1.<app-painel-simples tipo="primary" titulo="{{titulo}}" col="6">
2. <table class="table table-hover">
3.   <thead>
4.       <tr>
5.           <th>Especialidade</th>
6.           <th>Quantidade</th>
7.       </tr>
8.   </thead>
9.   <tbody>
10.     <tr *ngFor="let consulta of consultas">
11.       <td>{{consulta.especialidade}}</td>
12.       <td>{{consulta.quantidade}}</td>
13.     </tr>
14.   </tbody>
15. </table>
16.</app-painel-simples>
Explicando o código
Linha 1 <app-painel-simples tipo="primary" titulo="{{titulo}}" col="6">: Exibindo o título que esta na classe ConsultaPorEspecialidade.

Linha 10 <tr *ngFor="let consulta of consultas">: Iterando sobre o array consultas que esta na classe ConsultaPorEspecialidade.

Linha 11 E 12 <td>{{consulta.especialidade}}</td> e <td>{{consulta.quantidade}}</td>: Exibindo a especialidadee a quantidade que está no array consultas.

Editando o consulta.component.html
Se estamos recebendo estes dados de fora, alguém precisa passá-los, não é mesmo? Quem contém estes dados é o ConsultaComponent, fazemos isto no arquivo “consulta.component.html”.

Observando de outro ponto de vista, o ConsultaComponent utiliza o componente ConsultaPorEspecialidade para exibir a tabela, quem chama o componente é responsável por passar os dados necessários.

1.<app-consulta-por-especialidade
2.   titulo="Consultas Realizadas - Últimos 30 dias"
3.   [consultas]="consultas.realizadas">
4. </app-consulta-por-especialidade>
5.
6. <app-consulta-por-especialidade
7.   titulo="Consultas Marcadas - Próximos 30 dias"
8.   [consultas]="consultas.marcadas">
9. </app-consulta-por-especialidade>

Explicando o código
Linha 2 e 7 : titulo="Consultas Realizadas- Últimos 30 dias" e titulo="Consultas Marcadas - Próximos 30 dias". Definimos o titulo da tabela de consultas Realizadas e Marcadas, respectivamente.

Linha 3:[consultas]="consultas.realizadas">. Passando o array realizadas para o componente ConsultaPorEspecialidade, pois ele espera que receber uma lista de consultas para iterar.

Linha 4: [consultas]="consultas.marcadas">. Passamos um array de consultas para o componente ConsultaPorEspecialidade, porém agora estamos informando o array marcadas.

Note que ficou muito mais simples a visualização do código, pois agora consulta-por-especialidade encapsula a lógica de criação de uma tabela.

17. Criando Rotas

Como navegar entre a view consulta e a view resumo? O Angular trabalha com rotas, permitindo a navegação entre páginas sem a necessidade de carregar a página por completo.

Documentação
Para navegar entre as views utilizaremos o sistema de rotas do Angular. Para implementá-lo, no arquivo app.module.ts adicionaremos um array definindo as rotas:

1.let routes = [
2. { path : "resumo", component: ResumoComponent},
3. { path : "consulta", component: ConsultaComponent}
4.]
Explicando o código
Linha1: let routes = [... Criando um array que conterá as rotas, teremos mais que uma rota na aplicação, por isso um array de rotas.

Linha 2: { path : "resumo", component: ResumoComponent}, Linha 3: { path : "consulta", component: ConsultaComponent}. Rota para a aplicação, sendo path qual o nome da rota e component passamos qual componente queremos acessar, ou seja, quando acessar localhost:4200/resumo, deverá exibir o componente resumo.

Apenas definir este array routes não será suficiente para o Angular entender as rotas, precisamos carregá-las. Para isto utilizamos o módulo de rotas do Angular:

1.import { RouterModule } from '@angular/router';
2.
3.@NgModule({
4. declarations: [
5.   AppComponent,
6.   PainelSimplesComponent,
7.   BarraNavegacaoComponent,
8.   MenuLateralComponent,
9.   ResumoComponent,
10.   ConsultaComponent,
11.   ConsultaPorEspecialidadeComponent,
12. ],
13. imports: [
14.   BrowserModule,
15.   RouterModule.forRoot(routes)
16. ],
17. providers: [],
18. bootstrap: [AppComponent]
19.})
20.export class AppModule { }
Explicando o código
Linha 1 import { RouterModule } from '@angular/router';: Importando o módulo de rotas do Angular

Linha 15 RouterModule.forRoot(routes): Carregando as rotas definidas no array routes.

Estamos importando o módulo de rotas com as rotas carregadas, agora o nosso módulo principal AppModule, tem conhecimentos destas rotas.

Onde os componentes serão exibidos?
Agora precisamos indicar onde carregamos os componentes, quando acessarmos /resumo deve carregar a view Resumo, mas aonde? No mesmo local em que carregamos o componente Resumo e Consulta. A diferença é que utilizamos o componente de rotas para alternar dinamicamente entre os componentes Resumo e Consulta. Para isso editamos o arquivo app.component.html:

1.<app-barra-navegacao></app-barra-navegacao>
2.<div class="main">
3.   <app-menu-lateral></app-menu-lateral>
4.   <div class="content">
5.       <router-outlet></router-outlet>
6.   </div>
7.</div>
Explicando o código
Linha 5 <router-outlet></router-outlet>: Indicando onde será exibido o componente correspondente a rota acessada.

Adicionando os links
Temos que adicionar os links para que o usuário acesse as nossas rotas, fazemos isto no componente menu lateral dentro do arquivo menu-lateral.component.html.

1.<div class="menu menu-open">
2. <ul>
3.   <li class="visible-xs"><a href="#">Sair</a></li>
4.   <li><a routerLink="/resumo">Resumo</a></li>
5.   <li><a routerLink="/consulta">Consulta</a></li>
6. </ul>
7.</div>
Explicando o código
Linha 4: <li><a routerLink="/resumo">Resumo</a></li> e linha 5: <li><a routerLink="/consulta">Consulta</a></li>. Note que utilizamos routerLink, pois ele irá carregar apenas um trecho específico com o componente, diferente do atributo href que carrega a aplicação inteira.

repare que quando carregamos o módulo de rotas, o Angular passa a interpretar o atributo routerLink que nos permite navegar entre as rotas da aplicação, este atributo não existe no mundo HTML.

Criando uma rota padrão
Podemos adicionar uma rota padrão que irá redirecionar para a página inicial, fazemos isto alterando o array de rotas.

1.let routes = [
2. { path : "resumo", component: ResumoComponent},
3. { path : "consulta", component: ConsultaComponent},
4. { path : "faturamento", component: FaturamentoComponent},
5. { path : "**" , redirectTo:"/resumo"}
6.]
Explicando o código
Linha 5 { path : "**" , redirectTo:"/resumo"}: Qualquer rota diferente de resumo, consulta ou faturamento redicionará o cliente para /resumo.

Nota: A rota padrão deve ser a última a ser informada e nunca a primeira, caso contrário ela será sempre acionada.

Nota: Se não adicionarmos uma rota padrão, a pagina inicial será carregada em branco, pois não temos uma rota para “/”
Organizando as rotas
Uma boa prática é criar um módulo apenas para conter as nossas rotas, precisamos gerar este módulo com o seguinte comando:

ng g m app-routing-module --flat
Nota: Utilizamos a opção --flat para não criar um diretório para este módulo, ele ficará na raiz como o AppModule.

Dentro do arquivo app-routing-module.ts adicionaremos o seguinte código:

1.import { NgModule } from '@angular/core';
2.import { RouterModule } from '@angular/router';
3.import { ResumoComponent } from './resumo/resumo.component';
4.import { ConsultaComponent } from './consulta/consulta.component';
5.import { FaturamentoComponent } from
 './faturamento/faturamento.component';
6.
7.let routes = [
8. { path : "resumo", component: ResumoComponent},
9. { path : "consulta", component: ConsultaComponent},
10. { path : "faturamento", component: FaturamentoComponent},
11. { path : "**" , redirectTo:"/resumo"}
12.]
13.
14.@NgModule({
15. imports: [RouterModule.forRoot(routes)],
16. exports: [RouterModule]
17.})
18.export class AppRoutingModule { }
Explicando o código
Linha 2: import { RouterModule } from '@angular/router'; Importando o módulo de rotas.

Linha 3: import { ResumoComponent } from './resumo/resumo.component';, Linha 4: import { ConsultaComponent } from './consulta/consulta.component'; e Linha 5: import { FaturamentoComponent } from './faturamento/faturamento.component'; Estamos importando os componentes que serão utilizados nas rotas.

Linha 15: imports: [RouterModule.forRoot(routes)],Carregando as rotas e importando no módulo.

Linha 16: exports: [RouterModule] Podemos observar que temos a propriedade exports, pois precisamos exportar as rotas configuradas.

Importando as rotas em AppModule
Precisamos importar o AppRoutingModule em AppModule, assim a nossa aplicação carregará as rotas configuradas por AppRoutingModule. Lembrando que AppModule é o módulo principal da aplicação.

Adicionamos o seguinte código no arquivo app.module.ts:

1.import { AppRoutingModule} from './app-routing.module';
2.
3.@NgModule({
4. declarations: [
5.   AppComponent,
6.   PainelSimplesComponent,
7.   BarraNavegacaoComponent,
8.   MenuLateralComponent,
9.   ResumoComponent,
10.   ConsultaComponent,
11.   ConsultaPorEspecialidadeComponent
12. ],
13. imports: [
14.   BrowserModule,
15.   AppRoutingModule
16. ],
17. providers: [],
18. bootstrap: [AppComponent]
19.})
20.export class AppModule { }

Explicando o código
Linha 1: import { AppRoutingModule} from './app-routing.module'; Importando a classe AppRoutingModule do arquivo app-routing.module.ts. Este é o import que vimos nas aulas anteriores que é do JavaScript e TypeScript.

Da linha 13 até linha 15: AppRoutingModule. Importando o módulo AppRoutingModule no módulo AppModule. Note que estamos nos referindo ao import do Angular que é diferente do import no JavaScript ou TypeScript.

18. HTTP e Variável de Ambiente

Veremos como fazer as requisições com o HTTP do Angular, pois até agora só deixamos os dados fixos na classe.

Documentação
Até o momento, copiamos os dados da API e adicionamos na classe, tornando os dados fixos. Isto foi feito para evoluirmos o código gradativamente e nos possibilitou testar a aplicação antes de consultar o servidor. Agora, enviaremos uma requisição para esta API e receberemos os dados dinamicamente.

Um recurso muito utilizado no Front-End é o AJAX, que nos permite fazer requisições HTTP para trazer dados do servidor, sem que para isso seja necessário atualizar a página. Para isto utilizaremos o HttpClient do Angular. Para fazermos isto, importamos o seu módulo no arquivo app.module.ts:

1. import { HttpClientModule } from '@angular/common/http';
2.
3.@NgModule({
4. declarations: [
5.   //componentes...
6. ],
7. imports: [
8.   BrowserModule,
9.   AppRoutingModule,
10.   HttpClientModule //Carregando o módulo de HTTP
11. ],
12. providers: [],
13. bootstrap: [AppComponent]
14.})
15.export class AppModule {}
Explicando o código
Linha 1: import { HttpClientModule } from '@angular/common/http';Importando HttpClientModule do pacote @angular/common/http

Linha 10: HttpCientModule //Carregando o módulo de HTTP Importando o módulo HttpClientModule no módulo AppModule, ou seja, tornando disponível HttpClient em nossa aplicação.

Utilizando o HttpClient
Agora, utilizaremos o HttpClient para trazer os dados da view Resumo, para isto editamos o arquivo resumo.component.ts.

1. import { HttpClient } from '@angular/common/http';
2.
3. export class ResumoComponent implements OnInit {
4. resumo;
5.
6. constructor(private http:HttpClient) {}
7.}
Explicando o código
Linha 1 import { HttpClient } from '@angular/common/http';. Importando o HttpClient, Anteriormente importamos o HttpClientModule e neste arquivo estamos importando o HttpClient, portanto devemos nos atentar ao import correto.

Linha 4 resumo;: Removido os dados fixos do resumo, pois buscaremos estes dados do servidor.

Linha 6 constructor(private http:HttpClient) {}: O angular injetará o httpClient no nosso construtor, sem a necessidade de fazer um new HttpClient().

Fazendo requisições
Neste momento podemos utilizar o http como o atributo da classe e para fazer uma requisição, escrevemos o seguinte código:

1. export class ResumoComponent implements OnInit {
2. resumo;
3.
4. ngOnInit() {
5. this.http.get
("http://projeto.devmedia.com.br/php/api-dashboard/api/resumo")
6. .subscribe( dados => this.resumo = dados );
8. }
Explicando o código
Linha 5: this.http.get("http://projeto.devmedia.com.br/php/api-dashboard/api/resumo"). O métodothis.http.get retorna um observable, nele conseguimos se inscrever através do método subscribe, na linha 6, mas como isto funciona? Para a gente entender melhor, pense que um observable é um canal de notícias, então eu me inscrevo neste canal e quando tiver uma resposta eu recebo a notícia. Em nosso caso, estamos nos inscrevendo na requisição e quando ela obter sucesso, receberemos estes dados.

Linha 6: .subscribe( dados => this.resumo = dados ); Passamos uma função de callback que será executada quando a requisição obter sucesso, esta função recebe os dados que chegaram da requisição e atribui a this.resumo.

Note que escrevemos a lógica dentro de ngOnInit, pois queremos executar a requisição após construir o componente, e tudo que colocarmos dentro de ngOnInit será executado após o componente inicializar, tornando sua inicialização mais rápida!

NgIf
Tudo parece funcionar normalmente, entretanto o componente Resumo tenta acessar os dados antes que a requisição seja concluída. Isso acontece no arquivo resumo.component.html.

<h3 class="text-center">{{resumo.consultas.consultas_30dias_anteiores}}
</h3>

Só que resumo está nulo neste momento e isto gera um erro no JavaScript. Para corrigir esse comportamento, contamos com o ngIf. A partir dele só acessamos o resumo se o mesmo estiver preenchido.

<div *ngIf="resumo">
2.<app-painel-simples titulo="Consultas Marcadas Últimos 30 dias" col="6">
3.       <h3 class="text-center">
{{resumo.consultas.consultas_30dias_anteiores}}</h3>
4.   </app-painel-simples>
5.
6.  <!-- restante do código... -->
7.
8.</div>
Explicando o código
Linha 1: <div *ngIf="resumo">. Agora o Angular só irá exibir o que está dentro da div se o atributo resumo estiver preenchido pela requisição.

Obs.: erro no html (variavel escrita errado)

http://projeto.devmedia.com.br/php/api-dashboard/api/resumo

{
    "consultas" : {
	    "consultas_30dias_anteiores" : 87,
	    "consultas_30dias_posteriores" : 79
    },
    "faturamento" : {
    	"anterior" : {
	    	"valor" : 100000,
	    	"comparativo" : 19
	    },
	    "previsao" : {
	    	"valor" : 90000,
	    	"comparativo" : -10	
	    }
    }
}

9. Criando services

A nossa aplicação possui um comportamento comum a ser executado em diferentes componentes, a saber, trazer os dados da API. Quando encontramos esta necessidade podemos supri-la criando um serviço.

Documentação
O service terá a responsabilidade de conhecer a lógica que busca os dados da API, assim removemos esta responsabilidade do componente Resumo, tornando a sua leitura mais simples. Além disso, conseguimos isolar o código de infraestrutura necessário para a comunicação com a API em uma classe específica. Para criar um service digitamos o seguinte comando:

ng g service resumo/resumo --spec false
ou

ng g s resumo/resumo --spec false

Note que estamos criando o serviço resumo dentro do diretórioresumo.

Precisamos tornar este serviço injetável pelo angular, mas por que? Assim delegamos ao Angular a tarefa de instanciar a classe que o implementa, bem como passá-lo ao componente que o utilizará. Fazemos isto em AppModule

1. import { ResumoService } from './resumo/resumo.service';
2.
3.@NgModule({
4. declarations: [
5.//componentes
6. ],
7. imports: [
8.   BrowserModule,
9.   AppRoutingModule,
10.   HttpClientModule
11. ],
12. providers: [ResumoService],
13. bootstrap: [AppComponent]
14.})
15.export class AppModule { }
Explicando o código
Linha 1:import { ResumoService } from './resumo/resumo.service';. Importando o ResumoService.

Linha 12: providers: [ResumoService], Tornando a classe injetável pelo Angular, assim no arquivo resumo.component.ts conseguimos injetar em nosso construtor, assim como fizemos com o HttpClient.

Injetando o Resumo Service
Fazemos a injeção da dependência assim como fizemos com o HttpClient, recebendo o ResumoService no construtor:

1. import { ResumoService } from './resumo.service';
2.
3.export class ResumoComponent implements OnInit {
4.
5. resumo;
6.
7. constructor(private resumoService:ResumoService) {}
8.}
Explicando o código
Linha 1: import { ResumoService } from './resumo.service'; Importando o ResumoService.

Linha 7: constructor(private resumoService:ResumoService) {}.Injetando o ResumoService no construtor.

Codificando o ResumoService
Antes de utilizar o resumo service, precisamos escrever a lógica que traz os dados da API:

1. import { Injectable } from '@angular/core';
2. import { HttpClient } from '@angular/common/http';
3.
4.@Injectable()
5.export class ResumoService {
6.
7. constructor(private http:HttpClient) { }
8.
9. getResumo(){
10.   return this.http.get
("http://projeto.devmedia.com.br/php/api-dashboard/api/resumo");
11. }
12.
13.}
Explicando o código
Linha 2: import { HttpClient } from '@angular/common/http';. Importamos o HttpClient, e não o HttpClientModule. Existe outro pacote chamado @angular/http, que foi depreciado. Isto significa que a equipe do Angular não recomenda a utilização.

Linha 4: @Injectable(). Tornando a classe injetável pelo Angular conseguimos utilizá-la assim como o HttpClient, que é injetado no construtor.

Linha 9 e 10: Criando o método getResumo que retorna o observable.

Utilizando o ResumoService
1.export class ResumoComponent implements OnInit {
2.
3. resumo;
4. constructor(private resumoService:ResumoService) {}
5.
6. ngOnInit() {
7.   this.resumoService.getResumo()
8.   .subscribe( dados => this.resumo = dados);
9. }
10.}
Explicando o código
Linha 7: this.resumoService.getResumo(). Acessando o método getResumo que retorna um observable.

Linha 8: .subscribe( dados => this.resumo = dados);. Utilizando o método subscribe para se inscrever no observable, para isto passamos a função de callback como parâmetro e ela será executada no sucesso da requisição.

Nota: Neste momento temos o ResumoComponent apenas com a responsabilidade de exibir os dados, pois quem conhece como é feita uma requisição é o ResumoService.

Nota: Uma coisa importante a se mencionar é que a requisição só acontece quando chamamos a função subscribe.
Adicionando variável de ambiente
Note que, se o nosso servidor mudar o endereço, teremos que alterar a URL da aplicação em todos os nosso serviços. Este problema não é tão visível agora, pois temos um único serviço, o ResumoService.

Porém, para garantir uma melhor qualidade ao código, podemos resolver este problema utilizando o objeto environment. Nele podemos definir valores para compartilhar entre as classes da aplicação. Para isso, dentro do diretório src/enviroments, precisamos editar o arquivo environment.ts.

1. export const environment = {
2. production: false,
3. apiUrl:"http://projeto.devmedia.com.br/php/api-dashboard/api/"
4.};
Explicando o código
Linha 1: export const environment = {. Exportando uma variável constante chamada environment.

Linha 3: Adicionando a propriedade apiUrl para armazenar a URL da API, agora conseguimos compartilhar este valor entre todas as nossas classes e se precisarmos mudar seu valor, alteramos apenas em um único lugar!

Nota: Veremoso arquivo environment.prod.ts ao final do curso.
Utilizando o environment
Para acessar o environment no resumo.service.ts, escrevemos o seguinte código:

1. import { environment } from '../../environments/environment';
2.
3.@Injectable()
4.export class ResumoService {
5.
6. constructor(private http:HttpClient) { }
7.
8. getResumo(){
9.   return this.http.get(environment.apiUrl + "/resumo");
10. }
11.
12.}
Ao final do curso veremos a utilização do arquivo environment.prod.ts

Explicando o código
linha 1: import { environment } from '../../environments/environment'; Importando a constante environment.

linha 9: return this.http.get(environment.apiUrl + "/resumo");. Utilizando a propriedade apiUrl definida no environment, note que apenas concatenamos as strings, conseguimos acessar o environment em qualquer classe.

20. OnDestroy

Falaremos sobre o método OnDestroy e com ela entenderemos um pouco mais sobre os observables, uma forma de comunicar as alterações em um dados para componentes interessados nesta informação. Conheceremos algumas boas práticas que podemos adotar quando utilizamos observables.

Documentação
Quando nos inscrevemos em um observable geramos uma inscrição, como uma assinatura. Para dar início a este processo, precisamos guardar a inscrição em nossa classe, fazemos isto com o seguinte código:

1. export class ResumoComponent implements OnInit {
2.
3. resumo;
4. inscricao;
5.
6. constructor(private resumoService:ResumoService) {}
7.
8. ngOnInit() {
9.   this.inscricao = this.resumoService.getResumo()
10.   .subscribe( dados => this.resumo = dados);
11. }
12.
13. ngOnDestroy(){
14.   this.inscricao.unsubscribe();
15. }
16.}
Explicando o código
Linha 4: inscricao;. Atributo que armazena a inscrição gerada pelo método subscribe.

Linha 9: this.inscricao = this.resumoService.getResumo(). Armazenando a inscrição no atributo inscricao, esta inscrição é gerada quando chamamos o método subscribe.

Linha 13: ngOnDestroy(){. O componente possui um método chamado ngOnDestroy, o que escrevermos dentro desta função, será executado quando o componente for destruído.

Linha 14: this.inscricao.unsubscribe(); O método unsubscribe é chamado no exato momento que o componente for destruído, permitindo cancelar uma requisição se o componente deixar de existir na view.

Interface OnDestroy
É uma boa prática cancelar a inscrição quando o componente deixar de existir, ou seja, quando o ResumoComponent não estiver mais presente na view precisamos nos cancelar a inscrição.

Para isso, podemos adicionar a interface OnDestroy em nosso componente, assim fica obrigatório declarar esta função.

1.import { Component, OnInit, OnDestroy } from '@angular/core';
2.
3.export class ResumoComponent implements OnInit, OnDestroy {
4. //código da classe...
5.
6.}
Explicando o código
Linha 1: import { Component, OnInit, OnDestroy } from '@angular/core';. Importando a interface OnDestroy.

Linha 3: export class ResumoComponent implements OnInit, OnDestroy {. Implementando a interface OnDestroy.

Conhecendo o HttpClient
O HttpClient por padrão, já cancela a inscrição quando a requisição é concluída para liberar recursos utilizados pela inscrição. Entretanto se cancelar a inscrição no método ngOnDestroy permite cancelarmos a requisição, ou seja, se o usuário trocar de tela antes que a requisição seja concluída, ela será cancelada.

Podemos realizar este teste deixando a conexão slow 3g e navegando entre Resumo e Consulta antes da requisição ser concluída

21. Trazendo os dados da view consulta e o Safe Navigation Operator

Precisamos trazer os dados da API que representa a view consulta, assim como fizemos na view resumo. Veremos uma outra sintaxe do Angular que nos permite acessar um objeto nulo de forma segura, evitando causar um erro no JavaScript.

Documentação
Sabemos que é uma boa prática criar um service para trazer os dados da API. Para criá-lo digitamos o seguinte comando:

ng g s consulta/consulta --spec false
Não podemos esquecer de definir o service em providers no arquivo app.module.ts, para que o Angular passe a conhecer as classes que ele deve injetar.

1.import { ConsultaService } from './consulta/consulta.service';
2.
3.@NgModule({
4. declarations: [
5.   //componentes ...
6. ],
7. imports: [
8.   BrowserModule,
9.   AppRoutingModule,
10.   HttpClientModule
11. ],
12. providers: [ResumoService, ConsultaService],
13. bootstrap: [AppComponent]
14.})
15.export class AppModule { }
Explicando o código
Linha 1: import { ConsultaService } from './consulta/consulta.service';. Importando o ConsultaService.

Linha 12: providers: [ResumoService, ConsultaService], Tornando ConsultaService injetável pelo Angular.

Codificando o ConsultaService
Agora podemos escrever o nosso service:

1. import { Injectable } from '@angular/core';
2. import { HttpClient } from '@angular/common/http';
3.import { environment } from '../../environments/environment';
4.
5.@Injectable()
6.export class ConsultaService {
7.
8. constructor(private http:HttpClient) { }
9.
10. getConsultas(){
11.   return this.http.get(environment.apiUrl + '/consulta');
12. }
13.
14.}
Explicando o código
Linha 2: import { HttpClient } from '@angular/common/http';. Importando o HttpClient

Linha 3: import { environment } from '../../environments/environment';. Importando o environment

Linha 8: constructor(private http:HttpClient) { }. Adicionando o HttpClient no construtor para o Angular injetar esta dependência.

Linha 10 a 12: getConsultas(){. Criando o método que retornará as consultas. Não podemos esquecer de utilizar a variável de ambiente que contém apiUrl.

Utilizando o ConsultaService
Em ConsultaComponent, podemos acessar o serviço da seguinte forma:

1. import { Component, OnInit, OnDestroy } from '@angular/core';
2.import { ConsultaService } from './consulta.service';
3.
4.@Component({
5. selector: 'app-consulta',
6. templateUrl: './consulta.component.html',
7. styleUrls: ['./consulta.component.css']
8.})
9.export class ConsultaComponent implements OnInit, OnDestroy {
10.
11. consultas;
12. consultaInscricao;
13.
14. constructor(private consultaService:ConsultaService) { }
15.
16. ngOnInit() {
17.   this.consultaInscricao = this.consultaService.getConsultas()
18.   .subscribe( dados => this.consultas = dados)
19. }
20.
21. ngOnDestroy(){
22.   this.consultaInscricao.unsubscribe();
23. }
24.
25.}
Explicando o código
Linha 2: import { ConsultaService } from './consulta.service';.Importando o consulta service.

Linha 17: this.consultaInscricao = this.consultaService.getConsultas(). Guardando a inscrição no atributo consultaInscricao

Linha 18: .subscribe( dados => this.consultas = dados). Armazenando os dados da requisição no atributo consultas.

Linha 22: this.consultaInscricao.unsubscribe();. Se desinscrevendo do observable quando o componente for destruído, lembrando de adicionar o ngOnDestroy para se desinscrever do observable para poupar recursos do navegador e da API.

Safe Navigation operator
Temos o mesmo problema que aconteceu com ResumoComponent, estamos tentando acessar realizadas do atributo consultas, mas consultas só estará disponível quando a requisição for concluída.

<app-consulta-por-especialidade
2.   titulo="Consultas Realizadas - Últimos 30 dias"
3.   [consultas]="consultas.realizadas">
4. </app-consulta-por-especialidade>
Podemos adicionar o ngIf, entretanto temos uma solução mais fácil para este caso, o Safe Navigation Operator.

1.<app-consulta-por-especialidade
2.   titulo="Consultas Realizadas - Últimos 30 dias"
3.   [consultas]="consultas?.realizadas">
4. </app-consulta-por-especialidade>
5.
6. <app-consulta-por-especialidade
7.   titulo="Consultas Marcadas - Próximos 30 dias"
8.   [consultas]="consultas?.marcadas">
9. </app-consulta-por-especialidade>
Explicando o código
Linha 3: [consultas]="consultas?.realizadas">

linha 8: [consultas]="consultas?.marcadas">. Adicionamos o caracter “?”, assim o Angular só tenta acessar realizadas se consultas não estiver nulo ou undefined.

O ngIf não exibe o conteúdo do elemento caso a expressão passada retorne false.

Note ainda que safe navigation operator retorna nulo, caso o objeto verificado não esteja disponível. Então o componente consulta-por-especialidade receberá um objeto nulo.

Nota: O componente consulta-por-especialidade espera uma lista para iterar, mas isto não deveria causar um erro? O ngFor está preparado para estes casos, ele simplesmente ignora e não exibe a lista, até porque não temos uma lista.

22. Tratando erros na requisição

Caso um erro aconteça durante a navegação, precisamos informar que houve um erro.

Documentação
É comum erros ocorrerem quando estamos trabalhando na web, pois estamos suscetíveis a falhas de comunicação e o HttpClient nos permite tratar erros gerados pela requisição. Passaremos uma segunda função de callback para o subscribe, está função será executada apenas quando o erro ocorrer:

1.export class ConsultaComponent implements OnInit, OnDestroy {
2.
3. consultas;
4. consultaInscricao;
5. erro;
6.
7. constructor(private consultaService:ConsultaService) { }
8.
9. ngOnInit() {
10.   this.consultaInscricao = this.consultaService.getConsultas()
11.   .subscribe( 
12.       dados => this.consultas = dados,
13.       erro => this.erro = true);
14. }
15.
16. ngOnDestroy(){
17.   this.consultaInscricao.unsubscribe();
18. }
19.
20.}
Linha 5: erro;. Atributo que armazenará se houve um erro ou não.

Linha 13: erro => this.erro = true);. Função de callback que será executada quando ocorrer um erro, ela será responsável por armazenar um valor em this.erro. Este atributo (this.erro) conterá um valor booleano, ou seja, se este atributo conter o valor true é porque houve um erro na requisição. Passaremos este valor para outros componentes, assim eles serão notificados de que houve uma falha na comunicação.

Codificando o componente consulta-por-especialidade para receber o erro
Agora precisamos informar o consulta-por-especialidade que houve um erro, para que ele não mostre o seu conteúdo, ou seja, a tabela. Fazemos isto editando o arquivo consulta.component.html.

1. <app-consulta-por-especialidade
2.   titulo="Consultas Realizadas - Últimos 30 dias"
3. [consultas]="consultas?.realizadas"
4.   [erro]="erro">
5. </app-consulta-por-especialidade>
6.
7. <app-consulta-por-especialidade
8.   titulo="Consultas Marcadas - Próximos 30 dias"
9.   [consultas]="consultas?.marcadas"
10.   [erro]="erro">
11. </app-consulta-por-especialidade>
Explicando o código
Linha 5: erro;. Atributo que armazenará um valor booleano, true ou false. Isto será necessário para informar que houve um erro na requisição para o componente consulta-por-especialidade.

Linha 13: erro => this.erro = true); Função de callback que será executada quando ocorrer um erro. Ela será responsável por armazenar um valor em this.erro, que por sua vez conterá um valor booleano. Se este atributo contiver o valor true é porque houve um erro na requisição. Passaremos este valor para outros componentes, assim eles serão notificados de que houve uma falha na comunicação.

Passamos o atributo erro para o componente consulta-por-especialidade, assim ele sabe se houve um erro ou não.

Adicionando @Input no atributo erro
Mas consulta-por-especialidade não está preparado para receber este erro, então editaremos o arquivo consulta-por-especialidade.component.ts para que ele receba esta informação do componente Consulta.

1. export class ConsultaPorEspecialidadeComponent implements OnInit {
2.
3. @Input() consultas;
4. @Input() titulo;
5. @Input() erro;
6.
7. constructor() { }
8. ngOnInit() {}
9.
10.}
Explicando o código
Linha 5: @Input() erro;. Recebendo o atributo erro de um componente externo.

E finalmente o componente consulta-por-especialidade passa receber a informação de que houve um erro, faremos o tratamento editando o arquivo consulta-por-especialidade.component.html.

1. <app-painel-simples tipo="primary"
titulo="{{titulo}}" col="6">
2. <table *ngIf="!erro; else mensagem"
class="table table-hover">
3.   <thead>
4.       <tr>
5.           <th>Especialidade</th>
6.           <th>Quantidade</th>
7.       </tr>
8.   </thead>
9.   <tbody>
10.     <tr *ngFor="let consulta of consultas">
11.       <td>{{consulta.especialidade}}</td>
12.       <td>{{consulta.quantidade}}</td>
13.     </tr>
14.   </tbody>
15. </table>
16. <ng-template #mensagem>
17.   <h3 class="text-center">Falha na comunicação
 com o servidor</h3>
18. </ng-template>
19.</app-painel-simples>
Explicando o código
Linha 2: <table *ngIf="!erro; else mensagem" class="table table-hover">. Adicionamos o ngIf para exibir a tabela caso não tenha um erro, mas se houver, queremos exibir a mensagem. Na linha 16 criamos esta mensagem.

Linha 16: <ng-template #mensagem>. O ng-template é apenas para criarmos um container que receberá a mensagem, então apelidamos o ng-template de mensagem e caso aconteça um erro, será exibido o “<h3>” definido na linha 17.

Linha 17: <h3 class="text-center">Falha na comunicação com o servidor</h3>. Texto que será exibido caso ocorra um erro.

Testando a aplicação
Podemos testar desabilitando a internet no chrome

network - offline




